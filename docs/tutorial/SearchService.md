## Search service

### Table of contents <a name="TOC"></a>
- [Introduction](#introduction)
- [Search API access](#search-api-access)
- [Query](#query)
    * [Query by kind](#query-by-kind)
    * [Text Queries](#text-queries)
      + [Examples](#examples)
      + [Grouping](#grouping)
      + [Reserved characters](#reserved-characters)
      + [Wildcards](#wildcards)
    * [Sort](#sort-queries)
    * [Range Queries](#range-queries)
    * [Geo-Spatial Queries](#geo-spatial-queries)
      + [Geo Distance](#geo-distance)
        - [Distance Units](#distance-units)
      + [Geo Bounding Box](#bounding-box)
      + [Geo Polygon](#geo-polygon)
    *  [Cross-Kind Queries](#cross-kind-queries)
    *  [Cross-Partition Queries](#cross-partition-queries)
- [Query With Cursor](#query-with-cursor)
- [Get indexing status](#get-indexing-status)
- [Permissions](#permissions)

## Introduction <a name="introduction"></a>

The Search API provides a mechanims for indexing documents that contain structured data. You can search an index, and organize and present search results. Documents and indexes are saved in a separate persistent store optimized for search operations. The Search API can index any number of documents.

The API supports full text search on string fields, range queries on date, numeric or string fields etc. along with geo-spatial search.

## Search API access <a name="search-api-access"></a>

* Required roles

   Search service requires that users have dedicated roles in order to use it. Users must be a member of `users.osdu.viewers` or `users.osdu.editors` or `users.osdu.admins`, roles can be assigned using the [Entitlements Service](/solutions/osdu/tutorials/core-services/entitlementsservice). Please look at the API documentation for specific requirements.
   
  In addition to service roles, users __must__ be a member of data groups to access the data.

* Required headers

  The Data Ecosystem stores data in different partitions, depending on the different accounts in the OSDU system.

  A user may belong to more than one account.  As a user, after logging into the OSDU portal, you need to select the account you wish to be active. 
  Likewise, when using the Search APIs, you need to specify the active account in the header called OSDU-Data-Partition-Id. The correct OSDU-Data-Partition-Id can be obtained from the CFS services. The OSDU-Data-Partition-Id enables the search within the mapped partition. e.g.
  ```
  OSDU-Data-Partition-Id: OSDU
  ```
  
  There is also a special data partition known as “common”, which contains all public data in the Data Ecosystem, and is accessible to all users.
  ```
  OSDU-Data-Partition-Id: common
  ```

* Optional headers

  The Correlation-Id is a traceable ID to track the journey of a single request. The Correlation-Id can be a GUID on the header with a key. It is best practice to provide the Correlation-Id so the request can be tracked through all the services.
  ```
  OSDU-Correlation-Id: 1e0fef08-22fd-49b1-a5cc-dffa21bc0b70
  ```
 If the service is initiating the request, an ID should be generated. If the Correlation-Id is not provided, then a new ID will be generated by the service so that the request would be traceable. 

[Back to table of contents](#TOC)

## Query <a name="query"></a>

Data Ecosystem search provides a JSON-style domain-specific language that you can use to execute queries. Query request URL and samples are as follows:  

```
POST /api/search/v2/query
{
  "kind": "common:welldb:wellbore:1.0.0",
  "query": "data.Status:Active",
  "offset": 0,
  "limit": 30,
  "sort": {
    "field": ["id"],
    "order": ["ASC"]
  },
  "queryAsOwner": false,
  "spatialFilter": {
    "field": "data.Location",
    "byBoundingBox": {
      "topLeft": {
        "latitude": 37.450727,
        "longitude": -122.174762
      },
      "bottomRight": {
        "latitude": 36.450727,
        "longitude": -122.174762
      }
    }
  },
  "returnedFields": [ "data.Status" ]
}
```

<details><summary>**Curl**</summary>

```
curl --request POST \
  --url '/api/search/v2/query' \
  --header 'accept: application/json' \
  --header 'authorization: Bearer <JWT>' \
  --header 'content-type: application/json' \
  --header 'OSDU-Data-Partition-Id: common' \
  --data '{
  "kind": "common:welldb:wellbore:1.0.0",
  "query": "data.Status:Active",
  "offset": 0,
  "limit": 30,
  "sort": {
    "field": ["id"],
    "order": ["ASC"]
  },
  "queryAsOwner": false,
  "spatialFilter": {
    "field": "data.Location",
    "byBoundingBox": {
      "topLeft": {
        "latitude": 37.450727,
        "longitude": -122.174762
      },
      "bottomRight": {
        "latitude": 36.450727,
        "longitude": -122.174762
      }
    }
  },
  "returnedFields": [ "data.Status" ]
}'
```
__Note:__ : It can take a delay of atleast 30 seconds once records are successfully ingested via Storage service to become searchable in DE. You can check the [index status](#get-indexing-status).

</details>


#### Parameters <a name="parameters"></a>

| Parameter | Description |
| :--- | :--- |
| kind | The kind of the record to query e.g. 'common:welldb:wellbore:1.0.0'. kind is a __required__ field and can be formatted as OSDU-Data-Partition-Id:data-source-id:entity-type:schema-version |
| query | The query string in Lucene query string syntax. |
| offset | The starting offset from which to return results. |
| limit | The maximum number of results to return from the given offset. If no limit is provided, then it will return __10__ items. Max number of items which can be fetched by the query is __100__. (If you wish to fetch large set of items, please use [query_with_cursor](#query-with-cursor) API). |
| sort | Allows you to add one or more sorts on specific fields. The length of fields and the length of order must match. Order value must be either ASC or DESC (case insensitive). For more details, ability and limitation about this feature, please refer to [Sort](#sort_querires) 
| queryAsOwner | If true, the result only contains the records that the user owns. If false, the result contains all records that the user is entitled to see. Default value is false | 
| spatialFilter | A spatial filter to apply, please see [Geo-Spatial Queries](#geo-spatial-queries). |
| returnedFields | The fields on which to project the results. |

__Note:__ Offset + Limit can not be more than the 10,000. See the [Query With Cursor](#query-with-cursor) for more efficient ways to do deep scrolling.

### Query by kind <a name="query-by-kind"></a>

"kind" can be formatted as account-id:data-source-id:type:schema-version and a __required__ field. Available list of "kind" can be retrieved via [storage service](https://test-OSDUdev.devportal.apigee.io/solutions/ep-data-lake-services/apis/dev-data-lake-storage/getkinds). Users can make search documents just by providing "kind" as shown:

```
POST /api/search/v2/query
{
  "kind": "common:welldb:wellbore:1.0.0"
}
```
<details><summary>**Curl**</summary>

```
curl --request POST \
  --url '/api/search/v2/query' \
  --header 'accept: application/json' \
  --header 'authorization: Bearer <JWT>' \
  --header 'content-type: application/json' \
  --header 'OSDU-Data-Partition-Id: common' \
  --data '{
  "kind": "common:welldb:wellbore:1.0.0"
}'
```
</details>

The query will return 10 (default limit) documents for the kind. 

Wildcard queries on kind are also supported, please look at [Cross-Kind Queries](#cross-kind-queries) & [Cross-Partition Queries](#cross-partition-queries) for more information.

Data Ecosystem indexer also splits "kind" and index each part individually. These terms can then be queried by `query` request parameter, e.g. `common:welldb:wellbore:1.0.0` will be indexed as `namespace=common:welldb`, `type=well` and `version=1.0.0`. Data Ecosystem can be now queried to search based on one these attributes. 

### Text Queries <a name="text-queries"></a>

Data Ecosystem provides comprehensive query options in [Lucene query syntax](https://lucene.apache.org/core/2_9_4/queryparsersyntax.html). The query string is parsed into a series of terms and operators. A term can be a single word - "producing" or "well" - or a phrase, surrounded by double quotes - "producing well" - which searches for all the words in the phrase, in the same order. The default operator for query is __OR__.

A field in the document can be searched by using `<field-name>:<value>`. If field is not defined, then it defaults to all queryable fields; and the query will automatically attempt to determine the existing fields in the index’s mapping that are queryable, and perform the search on those fields. 

The query language is quite comprehensive and can be intimidating at first glance, but the best way to actually learn it is to start with a few basic examples.

__Note:__ __kind__ is a required parameter and is omitted for brevity in following examples. Also, all storage record properties are in 'data' block, any reference to a field inside the block should be prefixed with 'data.'

#### Examples <a name="examples"></a>

* search all fields which contains text 'well'

```json
{
  "query": "well"
}
```

__Note:__ In absence of `<field-name>`, the query string will automatically attempt to determine the existing fields in the index’s mapping that are queryable, and perform the search on those fields. Search query will be more performant if field name are specified in the query instead of searching across all queryable attribute. The following examples cover this:

* where the Basin field contains "Permian"

```json
{
  "query": "data.Basin:Permian"
}
```

* where the Rig_Contractor field contains "Ocean" or "Drilling". OR is the default operator

```json
{
  "query": "data.Rig_Contractor:(Ocean OR Drilling)"
}
```

or 

```json
{
  "query": "data.Rig_Contractor:(Ocean Drilling)"
}
```

* where the Rig_Contractor field contains the exact phrase "Ocean Drilling"

```json
{
  "query": "data.Rig_Contractor:\"Ocean Drilling\""
}
```

* where any of the fields ValueList.OriginalValue, ValueList.Value or ValueList.AppDataType contains "PRODUCING" or "DUAINE" (note how we need to escape the * with a backslash)

```json
{
  "query": "data.ValueList.\\*:(PRODUCING DUAINE)"
}
```

* where the field Status has any non-null value, use the \_exists\_ prefix for a field will search to see if the field exists

```json
{
  "query": "_exists_:data.Status"
}
```

#### Grouping <a name="grouping"></a>

Multiple terms or clauses can be grouped together with parentheses, to form sub-queries

```json
{
  "query": "data.Rig_Contractor:(Ocean OR Drilling) AND Exploration NOT Basin"
}
```

#### Reserved characters <a name="reserved-characters"></a>

If you need to use any of the characters which function as operators in your query itself (and not as operators), then you should escape them with a leading backslash. For instance, to search for (1+1)=2, you would need to write your query as \\(1\\+1\\)\\=2.

The reserved characters are: + - = && || > < ! ( ) { } [ ] ^ " ~ * ? : \ /

Failing to escape these special characters correctly could lead to a syntax error which prevents your query from running.

__Note:__ < and > can’t be escaped at all. The only way to prevent them from attempting to create a [range query](#range-queries) is to remove them from the query string entirely.

#### Wildcards <a name="wildcards"></a>

Wildcard searches can be run on individual terms, using ? to replace a single character, and * to replace zero or more characters.

```json
{
  "query": "data.Rig_Contractor:Oc?an Dr*"
}
```

Be aware that wildcard queries can use an enormous amount of memory and therefore can effect the performance.  They should be used very sparingly.

__Note:__ Leading wildcards are disabled by Data Ecosystem Search. Allowing a wildcard at the beginning of a word (e.g. "*ean") is particularly heavy, because all terms in the index need to be examined, just in case they match.

#### Date Format <a name="date-format"></a>

If you need to use date in your query, it has to be in one of the following formats

```
 date-opt-time = date-element ['T' [time-element] [offset]]
 
 Example : 2017-12-29T00:00:00.987
 
 Please note that the time element is optional
```
```
 date-element = std-date-element 
  
 std-date-element  = yyyy ['-' MM ['-' dd]]
 
 Example: 2017-12-29
```
```
 time-element = HH [minute-element] | [fraction]
 
 minute-element = ':' mm [second-element] | [fraction]
   
 second-element = ':' ss [fraction]
  
 fraction = ('.' | ',') digit+
   
 offset = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])
```
 
 For more info please refer [Date format](http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateOptionalTimeParser--)

## Sort <a name="sort-queries"></a>
The sort feature supports int, float, double, long and datetime, but it does not support array object, nested object or string field as of now, and for the records contain such types won't return in the response.

The records either does not have the sorted fields or have empty value will be listed last in the result.

E.g. Given 
     
1. here are 2 kinds match the request: common:welldb:wellbore:1.0.0 and common:welldb:well:1.0.0
2. data.Id in common:welldb:wellbore:1.0.0 has been ingested as INTEGER, but data.Id in common:welldb:well:1.0.0 has been ingested as TEXT
3. common:welldb:wellbore:1.0.0 has 10 records in total and 5 of them have empty value of data.Id field
4. common:welldb:well:1.0.0 also has 10 records in total and all of them have values in data.Id field
     
```json
{
  "kind": "common:welldb:*:*",
  "sort": {
    "field": ["data.Id"],
    "order": ["ASC"]
  }
}
``` 
The above request payload asks search service to sort on "data.Id" in an ascending order, and the expected response will have "totalCount: 10" (instead of 20, please note that the 10 returned records are only from common:welldb:wellbore:1.0.0 because the data.Id in common:welldb:well:1.0.0 is of data type string, which is not currently supported - and therefore, will not be returned) and should list the 5 records which have empty data.Id value at last.

**NOTE:** Search service does not validate the provided sort field, whether it exists or is of the supported data types. Different kinds may have attributes with the same names, but are different data types. Therefore, it is the user's responsibility to be aware and validate this in one's own workflow. 

The sort query could be very expensive, especially if the given kind is too broad (e.g. "kind": "*:*:*:*"). The current time-out threshold is 60 seconds; a 504 error ("Request timed out after waiting for 1m") will be returned if the request times out. The suggestion is to make the kind parameter as narrow as possible while using the sort feature.
 
## Range Queries <a name="range-queries"></a>

Ranges can be specified for date, numeric or string fields. Inclusive ranges are specified with square brackets `[min TO max]` and exclusive ranges with curly brackets `{min TO max}`. Here are some of the examples:

* All SpudDate in 2012

```json
{
  "query": "data.SpudDate:[2012-01-01 TO 2012-12-31]"
}
```

* Count 1..5

```json
{
  "query": "data.Count:[1 TO 5]"
}
```

* Count from 10 upwards

```json
{
  "query": "data.Count:[10 TO *]"
}
```

* Ranges with one side unbounded can use the following syntax

```json
{
  "query": "data.ProjDepth:>10"
}
```

* combine an upper and lower bound with the simplified syntax, you would need to join two clauses with an AND operator

```json
{
  "query": "data.ProjDepth:(>=10 AND <20)"
}
```

[Back to table of contents](#TOC)


## Geo-Spatial Queries <a name="geo-spatial-queries"></a>

Data Ecosystem supports geo-point geo data which supports lat/lon pairs. `spatialFilter` and `query` group in the request have AND relationship. If both of the criteria are defined in the query, then the search service will return results which match both clauses. 

The queries in this group are [Geo Distance](#geo-distance), [Geo Polygon](#geo-polygon) and [Bounding Box](#bounding-box). Only __one__ spatial criteria can be used while defining filter.

### Geo Distance <a name="geo-distance"></a>

Filters documents that include only hits that exist within a specific distance from a geo point.

```
POST /api/search/v2/query
{
  "kind": "common:welldb:wellbore:1.0.0",
  "spatialFilter": {
    "field": "data.Location",
    "byDistance": {
      "point": {
        "latitude": 37.450727,
        "longitude": -122.174762
        },
        "distance": 1500
    }
  },
  "offset": 0,
  "limit": 30
}
```

<details><summary>**Curl**</summary>

```
curl --request POST \
  --url '/api/search/v2/query' \
  --header 'accept: application/json' \
  --header 'authorization: Bearer <JWT>' \
  --header 'content-type: application/json' \
  --header 'OSDU-Data-Partition-Id: common' \
  --data '{
  "kind": "common:welldb:wellbore:1.0.0",
  "spatialFilter": {
    "field": "data.Location",
    "byDistance": {
      "point": {
        "latitude": 37.450727,
        "longitude": -122.174762
        },
        "distance": 1500
    }
  },
  "offset": 0,
  "limit": 30
}'
```
</details>

| Parameter | Description |
| :--- | :--- |
| field | `geo-point` field in the index on which filtering will be performed. |
| distance | The radius of the circle centered on the specified location. Points which fall into this circle are considered to be matches. The distance can be specified in various units. See [Distance Units](#distance-units) |
| point.latitude | latitude of field. |
| point.longitude | longitude of field. |

### Distance Units <a name="distance-units"></a>

If no unit is specified, then the default unit of the distance parameter is meter. Distance can be specified in other units, such as "1km" or "2mi" (2 miles).

__Note:__ In the current version, the Search API only supports distance in meters. In future versions, distance in other units will be made available. The maximum value of distance is 1.5E308.

### Bounding Box <a name="bounding-box"></a>

A query allowing to filter hits based on a point location within a bounding box.

```
POST /api/search/v2/query
{
  "kind": "common:welldb:wellbore:1.0.0",
  "spatialFilter": {
    "field": "data.Location",
    "byBoundingBox": {
      "topLeft": {
        "latitude": 37.450727,
        "longitude": -122.174762
        },
      "bottomRight": {
        "latitude": 37.438485,
        "longitude": -122.156110
      }
    }
  },
  "offset": 0,
  "limit": 30
}
```

<details><summary>**Curl**</summary>

```
curl --request POST \
  --url '/api/search/v2/query' \
  --header 'accept: application/json' \
  --header 'authorization: Bearer <JWT>' \
  --header 'content-type: application/json' \
  --header 'OSDU-Data-Partition-Id: common' \
  --data '{
  "kind": "common:welldb:wellbore:1.0.0",
  "spatialFilter": {
    "field": "data.Location",
    "byBoundingBox": {
      "topLeft": {
        "latitude": 37.450727,
        "longitude": -122.174762
        },
      "bottomRight": {
        "latitude": 37.438485,
        "longitude": -122.156110
      }
    }
  },
  "offset": 0,
  "limit": 30
}'
```
</details>

| Parameter | Description | 
| :--- | :--- |
| field | `geo-point` field in the index on which filtering will be performed. |
| topLeft.latitude | latitude of top left corner of bounding box. |
| topLeft.longitude | longitude of top left corner of bounding box. |
| bottomRight.latitude | latitude of bottom right corner of bounding box. |
| bottomRight.longitude | longitude of bottom right corner of bounding box. |

### Geo Polygon <a name="geo-polygon"></a>

A query allowing to filter hits that only fall within a polygon of points.

```
POST /api/search/v2/query
{
  "kind": "common:welldb:wellbore:1.0.0",
  "spatialFilter": {
    "field": "data.Location",
    "byGeoPolygon": {
      "points": [
        {"longitude":-90.65, "latitude":28.56},
        {"longitude":-90.65, "latitude":35.56},
        {"longitude":-85.65, "latitude":35.56},
        {"longitude":-85.65, "latitude":28.56},
        {"longitude":-90.65, "latitude":28.56} 
      ]
    }
  },
  "offset": 0,
  "limit": 30
}
```

<details><summary>**Curl**</summary>

```
curl --request POST \
  --url '/api/search/v2/query' \
  --header 'accept: application/json' \
  --header 'authorization: Bearer <JWT>' \
  --header 'content-type: application/json' \
  --header 'OSDU-Data-Partition-Id: common' \
  --data '{
  "kind": "common:welldb:wellbore:1.0.0",
  "spatialFilter": {
    "field": "data.Location",
    "byGeoPolygon": {
     "points": [
        {"longitude":-90.65, "latitude":28.56},
        {"longitude":-90.65, "latitude":35.56},
        {"longitude":-85.65, "latitude":35.56},
        {"longitude":-85.65, "latitude":28.56},
        {"longitude":-90.65, "latitude":28.56} 
      ]
    }
  },
  "offset": 0,
  "limit": 30
}'
```
</details>

| Parameter | Description | 
| :--- | :--- |
| field | `geo-point` field in the index on which filtering will be performed. |
| points | list of `geo-point` describing polygon. |


[Back to table of contents](#TOC)


## Cross-Kind Queries <a name="cross-kind-queries"></a>

Data Ecosystem search supports cross-kind queries. A typical kind can be formatted as account-id:data-source-id:type:schema-version. Each of the text partitioned by ':' can be replaced with wildcard characters to support cross-kind search.

* search across all data-source, types & versions for common

```json
{
  "kind": "common:*:*:*"
}
```

* search across all data-source, type well with schema version 1.0.0

```json
{
  "kind": "common:*:well:1.0.0"
}
```

* search across all types and versions for welldb namespace in common

```json
{
  "kind": "common:welldb:*:*"
}
```

[Back to table of contents](#TOC)


## Cross-Partition Queries <a name="cross-partition-queries"></a>

In addition to cross-kind queries, Data Ecosystem search also supports cross-partition queries thus enabling users to search records from muliple partitions. Only one private and common partition are supported for cross-partition searches. To call it, one should provide comma separated list of partitions in OSDU-Data-Partition-Id. Cross-partition search of course deals with larger data set and entitlements from multiple partitions so it will always be less performant than single-partition search. We should have this in mind when designing queries so that they are optimized for the use case in question.

* search across all types and versions for welldb namespace in `common` and `common` partitions

```
POST /api/search/v2/query
OSDU-Data-Partition-Id: common,common
{
  "kind": "*:welldb:*:*"
}
```

<details><summary>**Curl**</summary>

```
curl --request POST \
  --url '/api/search/v2/query' \
  --header 'accept: application/json' \
  --header 'authorization: Bearer <JWT>' \
  --header 'content-type: application/json' \
  --header 'OSDU-Data-Partition-Id: common,common' \
  --data '{
  "kind": ":welldb:*:*"
}'
```
</details>

__Note:__ Cross-partition queries are only supported to one `private` & `common` partition, no other combinations are supported at this time.

[Back to table of contents](#TOC)


## Query With Cursor <a name="query-with-cursor"></a>

While a search request returns a single “page” of results, the `query_with_cursor` API can be used to retrieve large numbers of results (or even all results) from a single search request, in much the same way as you would use a cursor on a traditional database.

Cursor API is not intended for real time user requests, but rather for processing large amounts of data.

The [parameters](#parameters) passed in the request body are exactly the same as the `query` API except for the offset and cursor values. Please note that offset is not a valid parameter in `query_with_cursor` API

__Note:__ The results that are returned from a `query_with_cursor` request reflect the state of the index at the time that the initial search request was made, like a snapshot in time. Subsequent changes to documents (index, update or delete) will only affect later search requests.

In order to use the `query_with_cursor` request, initial search request should use the following:

```
POST /api/search/v2/query_with_cursor
{
  "kind": "common:welldb:wellbore:1.0.0",
  "query": "data.Status:Active",
  "limit": 30,
  "spatialFilter": {
    "field": "data.Location",
    "byBoundingBox": {
      "topLeft": {
        "latitude": 48.450727,
        "longitude": -122.174762
      },
      "bottomRight": {
        "latitude": 37.450727,
        "longitude": -122.174762
      }
    }
  },
  "returnedFields": [ "data.Status" ]
}
```

<details><summary>**Curl**</summary>

```
curl --request POST \
  --url '/api/search/v2/query_with_cursor' \
  --header 'accept: application/json' \
  --header 'authorization: Bearer <JWT>' \
  --header 'content-type: application/json' \
  --header 'OSDU-Data-Partition-Id: common' \
  --data '{
  "kind": "common:welldb:wellbore:1.0.0",
  "query": "data.Status:Active",
  "limit": 30,
  "spatialFilter": {
    "field": "data.Location",
    "byBoundingBox": {
      "topLeft": {
        "latitude": 48.450727,
        "longitude": -122.174762
      },
      "bottomRight": {
        "latitude": 37.450727,
        "longitude": 22.174762
      }
    }
  },
  "returnedFields": [ "data.Status" ]
}'
```
</details>

The successful response from the above request will include a "cursor", which should be passed to next call of `query_with_cursor` API in order to retrieve the next batch of results.    

```
POST /api/search/v2/query_with_cursor
{
  "kind": "common:welldb:wellbore:1.0.0",
  "cursor": "cursor-key"
}
```

<details><summary>**Curl**</summary>

```
curl --request POST \
  --url '/api/search/v2/query_with_cursor' \
  --header 'accept: application/json' \
  --header 'authorization: Bearer <JWT>' \
  --header 'content-type: application/json' \
  --header 'OSDU-Data-Partition-Id: common' \
  --data '{
  "kind": "common:welldb:wellbore:1.0.0",
  "cursor": "cursor-key"
}'
```
</details>

__Caution:__ As next batches of results are retrieved by `query_with_cursor` API, cursor value may or may not change. API users should not expect different cursor value in each `query_with_cursor` response.

__Note:__ To process the next `query_with_cursor` request, the search service keeps the search context alive for 1 minute, which is the time required to process the next batch of results. Each cursor request sets a new expiry time. The cursor will expire after 1 min and won't return any more results if the requests are not made in specified time.

[Back to table of contents](#TOC)


## Get indexing status <a name="get-indexing-status"></a>

Indexer service adds internal meta data to each record which registers the status of the indexing. The meta data includes the status and the last indexing date and time. This additional meta block helps to see the details of indexing. The format of the index meta block is as follows:

```
"index": {
    "trace": [
        String,
        String
    ],
    "statusCode": Integer,
    "lastUpdateTime": Datetime
}
```
Example:
```
{
    "results": [
        {
            "index": {
                "trace": [
                    "datetime parsing error: unknown format for attribute: endDate | value: 9000-01-01T00:00:00.0000000",
                    "datetime parsing error: unknown format for attribute: startDate | value: 1990-01-01T00:00:00.0000000"
                ],
                "statusCode": 400,
                "lastUpdateTime": "2018-11-16T01:44:08.687Z"
            }
        }
    ],
    "totalCount": 31895
} 
```

Details of the index block:
1) trace: This field collects all the issues related to the indexing and concatinates using '|'. This is a String field.
2) statusCode: This field determines the category of the error. This is integer field. It can have the following values:
    * 200 - All OK
    * 404 - Schema is missing in Storage
    * 400 - Some fields were not properly mapped with the schema defined
3) lastUpdateTime: This field captures the last time the record was updated by by the indexer service. This is datetime field so you can do range queries on this field.

You can query the index status using the following example query:

```
curl --request POST \
  --url /api/search/v2/query \
  --header 'Authorization: Token' \
  --header 'Content-Type: application/json' \
  --header 'OSDU-Data-Partition-Id: Data partition id' \
  --data '{"kind": "*:*:*:*","query": "index.statusCode:404","returnedFields": ["index"]}'
  
NOTE: By default, the API response excludes the 'index' attribute block. The user must specify 'index' as the 'returnedFields" in order to see it in the response.
```
The above query will return all records which had problems due to fields mismatch.


[Back to table of contents](#TOC)

## Permissions <a name="permissions"></a>

| **_Endpoint URL_** | **_Method_** | **_Minimum Permissions Required_** | **_Data Permissions Required _** |
| --- | --- | --- | --- |
| /api/search/v2/query | POST | users.osdu.viewers | Yes |
| /api/search/v2/query_with_cursor | POST | users.osdu.viewers | Yes |

[Back to table of contents](#TOC)
